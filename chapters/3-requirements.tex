\chapter{System Requirements and Design}
\label{chap:req}

\section{Requirements}

The requirements for the proof assistant (and its VS Code extension) can be divided into two categories:
core features and user experience features.
Core features are the necessary functionalities and properties that the proof assistant must possess in order to support
a language server without too much difficulty.
User experience features are the functionalities that do not affect the internal design of the proof assistant itself,
but help provide a pleasant user experience.

\subsection{Core features}

Since the \Rzk{} proof assistant itself is already in development and has a working typechecker,
the focus here is on the features that are necessary for the proof assistant to be used in an interactive setting.
So far, the proof assistant only had a command-line interface (CLI) that typechecked all the input files
every time the user wanted to check a proof.
It was clear that this was not a sustainable way to develop proofs, especially for larger projects.
Thankfully, there was a clear separation between the core typechecking algorithm and the interface to it as a library,
simplifying the work to just modifying the interface part without touching the algorithm.

This interface is required to support incremental typechecking, which is a feature that allows the user to typecheck
only the parts of the code that have changed since the last typecheck, speeding up the process significantly.
This is similar to TypeScript's incremental compilation feature, which caches information during each compilation
and then only compiles the files that have changed since the last compilation \cite{Vanderkam2024}.
To achieve this, the interface must be able to cache the typechecking results in memory and update them as needed.
The caching module should additionally be able to handle different methods of caching, such as in-memory or on-disk caching,
since there can be different user interfaces with different requirements (such as a CLI vs. language server).

The ability to support different user interfaces is important since the proof assistant is not limited to just VS Code.
Consumers of the proof assistant are not even necessarily humans who would prefer some sort of graphical interface,
but could also be other software tools, such as Continuous Integration (CI) pipelines or other sattelite tools.
Therefore, a command-line interface is also necessary, which would allow the proof assistant to be used in a non-interactive setting.

Lastly, the proof assistant interface must be designed in a way that allows for easy extension and modification,
leading to a short development cycle for new features.
This is especially important for a proof assistant that is still in development and has a lot of features planned for the future.

% "query" support (WIP)

\subsection{User Experience features}

The main purpose of the core features described above is to aid in improving the user experience of the proof assistant.
These UX requirements are not necessarily just features or functionalities, but also properties the proof assistant must possess.

The most important of these properties is the ease of use for beginners (or non-programmers) and an intuitive interface.
This is crucial for the proof assistant to be adopted by a wider audience, as the target users are not necessarily
experienced programmers.
In any way, the editing experience has to be comfortable to any kind of user.

Fast feedback on input is another important property that must be present in the proof assistant.
This includes, for example, diagnostic messages that are displayed as soon as the user types something wrong,
as well as hover information that shows the type of a variable and its definition location when the user hovers over it with the mouse.
It also includes providing code completions and suggestions as the user types, which can help prevent the use of undefined variables.
Users also expect to be able to jump to the definition of a variable or find all references to it.

Lastly, features that are common to most popular IDEs such as git integration, debugging, and refactoring tools are also expected.

\section{Design}

Judging by the aforementioned requirements, it is clear that the proof assistant must be able to support a language server.
Additionally, the language server should be implemented using LSP specifically to allow for easy integration with
different editors without having to write a dedicated extension or plugin for each text editor.
The proof assistant's core would expose an interface that the language server can use to interact with it,
as well as a CLI that can be used for non-interactive purposes.

The language server itself would be implemented in Haskell, as the proof assistant is written in Haskell as well.
This would allow for easy integration with the proof assistant's core and would make it easier to maintain the codebase.

The system can be divided into the following components: core typechecker, CLI, language server, VS Code extension, and utility tools.
The core typechecking algorithm is the heart of the proof assistant and is responsible for checking the proofs for correctness;
it is outside the scope of this project, which assumes its readiness and builds upon it.

Then there is the interface of the typechecker, which can be split into two parts: the CLI and the language server.
The CLI is a simple interface that allows the user to typecheck a file or a project from the command line.
It is also useful for non-interactive use, such as in continuous integration pipelines or other tools.
Its simplicity additionally makes it a sensible interface to use for testing newly added features since
there are less moving parts to worry about.

The other interface is the language server, which is responsible for providing an interactive interface to the proof assistant.
It is the more user-friendly of the two interfaces and is the one that will be used by most users.
It is implemented using Microsoft's Language Server Protocol to allow for easy integration with different text editors,
such as VS Code, Vim, or Emacs.
The language server is also responsible for providing the features that are expected from a modern programming language,
such as code completions, diagnostic messages, and hover information.

The VS Code extension is a thin wrapper around the language server that helps easily download a copy of the language server
and integrate it with VS Code.
It does so by checking the releases page in the GitHub repository\footnote{\url{https://github.com/rzk-lang/rzk/releases}}
and downloading the latest appropriate binary for the user's operating system, which is then cached in extension's
local storage directory provided by VS Code.
The extension also makes it easy to build the language server from source if the user prefers to do so.
Additionally, it exposes the option to specify a custom path for the language server for easier testing and development.

The VS Code extension is made available on multiple platforms, including the Visual Studio Marketplace, Open VSX, and the GitHub repository.
This is to ensure that the extension is easily discoverable by users and can be installed from multiple sources, especially for users
who prefer not to use Microsoft's proprietary software and instead opt for alternatives like VSCodium\footnote{\url{https://vscodium.com}}.
VSCodium can be configured to use Open VSX as its extension marketplace, which allows users to install the extension from there.
Having the ".vsix" file itself on the GitHub repository's releases page also contributes to the openness and flexibility of the project
and allows users to install the extension manually if they prefer.
Releasing to all of those platforms is automated using GitHub Actions, which builds the extension and uploads it to the respective marketplace.

Lastly, there are utility tools developed on the side to help with minor tasks related to the use of the proof assistant.
For example, there is a Python plugin\footnote{\url{https://pypi.org/project/mkdocs-plugin-rzk/}} for MkDocs that automates rendering
SVG files in a formalization project that utilizes MkDocs, which is useful for rendering topes as images in the resulting documentation.
Another tool is a GitHub Action\footnote{\url{https://pypi.org/project/mkdocs-plugin-rzk/}} that simplifies the process
of installing \Rzk{} in a CI pipeline and running it on the project files.
