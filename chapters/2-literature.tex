\chapter{Literature Review}
\label{chap:lr}
\chaptermark{Second Chapter Heading}

This work builds on several areas of research, including proof assistants, language servers,
and query-based compiler architectures.
In this chapter, we review the most relevant literature in these areas.

\section{Proof Assistants}

\Rzk{}~\cite{kudasov2023experimental} builds on recent efforts by other proof assistants to provide a
more user-friendly interface for theorem proving, especially related to synthetic $\infty$-categories.
In this section, we review some of the most popular proof assistants and libraries for proof assistant development.

\subsection{Proof assistants with support for synthetic $\infty$-categories}

\subsubsection{Coq}

Coq \cite{huet1997coq} is one of the earliest proof assistants that are still widely used in the research community.
It is based on the calculus of inductive constructions and is known for its support for dependent types and inductive types.
Coq is used in a variety of research areas, including formal verification, programming language theory, and mathematics.

Univalent foundations (and hence also Homotopy Type Theory) support in Coq is provided by the UniMath library~\cite{DanielGrayson2024}\cite{MacPherson2019}.

\subsubsection{Cubical Agda}

Agda \cite{BoveDybjerNorell2009} is a proof assistant based on the propositions-as-types paradigm~\cite{Wadler2015} originally developed by the Chalmers University of Technology in Sweden.
Agda is known for its support for inductive types, coinductive types, and a rich type system that allows for the
development of proofs and programs in a single language.
Agda is used in a variety of research areas, including formal verification, programming language theory, and mathematics.

Cubical Agda \cite{VEZZOSI2021} is a mode of operation for Agda that extends the language with a cubical type theory \cite{Cohen2016} based on the univalence axiom.
It allows to formalize Homotopy Type Theory and Univalent Foundations in Agda.

\subsubsection{Lean 4}

Lean is a functional programming language and a proof assistant based on the calculus of constructions with inductive types.
It is developed by Microsoft Research, with the first version released in 2013.
The first two versions were experimental and supported Homotopy Type Theory, but that support was later dropped.
Lean 3 was the first stable version, but it reached its end-of-life after Lean 4 was released in 2021, adding many features to the language in a backwards-incompatible manner.

\subsection{Libraries for proof assistant development}

\subsubsection{Proof General}

Proof General \cite{Aspinall2000} is a tool for developing interactive theorem
provers that has been used for many widely-known proof assistants such as Coq
and Isabelle.
It is based on the Emacs editor and provides an interactive GUI with relative
ease for theorem provers developed using it.
The interface produced by Proof General is familiar to many users of interative theorem
provers, making it useful as a reference when developing the interface of a new proof assistant.

\subsubsection{A.L.G.A.E.}

A.L.G.A.E. \footnote{\url{https://redprl.org/\#algae}} is a project that aims to provide a set
of composable libraries for developing proof assistants in OCaml.
The team behind it has built a set of tools that help with compiler diagnostics,
universe levels \cite{Kovacs2021}, cubical type theory support, and more.
They also used it to build a proof assistant called RedRPL.

\section{Language Server Protocol}

The Language Server Protocol is a common protocol for programming language analyzers to communicate with development tools. It was developed by Microsoft in an effort to decouple a language's implementation from its editor interface \cite{Buender2019} and has contributed significantly to decreasing the effort required to add support for a given programming language in a given text editor (that supports LSP). The Language Server Protocol is used between a tool (the client) and a language smartness provider (the server) to integrate features like auto complete, go to definition, find all references and alike into the tool. The Language Server Protocol is used by many development tools like Visual Studio Code, Eclipse, Emacs, Sublime Text, Atom, and Vim.

Its development started on June 27, 2016 by Microsoft, which then collaborated with Red Hat and Codenvy to standardize the protocol's specifictation and release it under the Creative Commons Attribution license.
The protocol is based on JSON-RPC and is designed to be language agnostic, meaning that it can be used with any programming language.

% https://www.infoworld.com/article/3088698/microsoft-backed-langauge-server-protocol-strives-for-language-tools-interoperability.html
% https://sdtimes.com/che/codenvy-microsoft-red-hat-collaborate-language-server-protocol/

\subsection{Specification Language Server Protocol}

While LSP has greatly improved the experience of developing language servers,
it still leaves something to be desired.
LSP was mainly designed with general purpose programming languages in mind,
but theorem provers (or, more generally, specification language) have slightly
different requirements that are unmet by LSP.
This is why Jonas Rask et al. \cite{JonasKjaerRask2021} attempt to extend the original LSP
specification with features that are especially useful for specification languages.
The authors call the protocol extension \textit{Specification Language Server Protocol} (SLSP).
Simply speaking, it defines a set of new LSP requests and/or notifications and
their payloads, and extends VS Code's interface with a view that displays proof
information in a way that is visually similar to Proof General \cite{Aspinall2000}.

The motivation behind it is that LSP by itself was not designed with \textit{specification languages}
(including theorem provers) in mind, rendering it insufficiently adequate for them.
SLSP is an attempt at defining a protocol extension for LSP designed for specification languages.
It adds features useful for specification languages such as special requests and notifications,
a proof view similar to Lean's Info View panel, and interactivity using the Debug Adapter Protocol (DAP).
It also adds numerous other features such as code generation, conversion to other specification languages,
UML vizualization, test automation, and more.

\subsection{VS Code extension for Lean 4.}

Lean 4 \cite{deMouraUllrich2021} is a programming language and proof assistant
by Microsoft Research\footnote{\url{https://www.microsoft.com/en-us/research/project/lean/}}
from which we draw much inspiration.
In particular, the primary way to develop Lean programs is using its VS Code
extension that provides a user interface for working with Lean interactively.
This extension uses LSP to communicate with the Lean server and provides a lot
of useful features, the most notable of which is the Info View panel that
displays information about current proof state and allows interacting with it \cite{Nawrocki2023}.
Another feature it provides is finding all references for a particular symbol~\cite{Mennicken2022}.

\subsection{Reports on language servers for proof assistants}

There have been several reports on the development of language servers for proof assistants.
For example, Bour et al.~\cite{Bour2018} report on the development of a language server for OCaml,
Kaliszyk~\cite{Kaliszyk2007} describes a proposed architecture for web interfaces for proof assistants,
implementing a prototype of an interface for Coq, while Tavante~\cite{Tavante2021} studies the
tools and interfaces surrounding proof assistants and their usability.
Lastly, BÃ¼nder and Kuchen~\cite{Buender2020} investigate how LSP can be used to integrate
Domain Specific Languages (DSL) into different code editors.

\section{Query-based Compiler Architecture}

Traditionally, the compilation process involved five phases \cite{dragon-book}:
\begin{enumerate}
  \item Lexical analysis
  \item Parsing
  \item Semantic analysis (including type checking)
  \item Code generation
  \item Optimization
\end{enumerate}

These phases are not necessarily rigid; many compilers would slightly deviate from them.
For example, some compilers would involve additional phases (such as linking),
some would merge a few of the phases together (such as lexical scanning and parsing),
while some compilers would skip a stage altogether (such as optimization).
However, the main fact remains that the compilation process overall had a linear pipeline
architecture, where the output of one phase was the input to the next phase.

Query-based compiler architecture \cite{ollef-rock} is a relatively new architecture for
compilers that is designed for interactive programming environments.
It splits the compilation phases into a much more granular model where each phase is
represented as a query that can be run independently.
This architecture can be modelled as more of a graph than a pipeline, where each node
is a query and each edge is a dependency between queries.
The results of such queries can be cached and reused, which can greatly speed up the
response time in interactive environments, making it a good fit for language servers.

While there has not been much research on query-based compiler architecture compared
to the classical architectures, there is evidence for its applications since the year 1997,
particularly in using it for debugging programs object-oriented programs \cite{Lencevicius1997},
which is a use case very similar to that of language servers.

Recently, Lenkefi and Mezei \cite{icsoft22} demonstrated the use of query-based compilers
by developing a library for query-based compilers and using it to implement a compiler
for a simple programming language they designed, along with a language server in LSP
that uses the compiler to provide language features in VS Code.
This compiler is designed with incrementality in mind, meaning that it can recompile
only the parts of the program that have changed.

Furthermore, a technique that helps radically speed up such interactive compilers
is incremental parsing~\cite{Ghezzi1979}\cite{diekmann2019editing}\cite{Wagner1998},
in which the Abstract Syntax Tree is patched with modifications to the source code
rather than performing the syntax analysis from scratch on every minor edit.
Many parser generators already incorporate this technology, such as
Tree-sitter~\cite{tree-sitter} and Ohm~\cite{Dubroy2017}.
